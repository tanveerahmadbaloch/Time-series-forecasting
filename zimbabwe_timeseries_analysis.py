# -*- coding: utf-8 -*-
"""Zimbabwe_TimeSeries_Analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zRrpe0PFC_LbRU6oh_nqDWx_DfL3L59a

# **Zimbabwe Data w.r.t Temperature Time Series Analysis**
"""



!pip install pmdarima

#Import the necessary packages
import pandas as pd
import numpy as np
import pywt
from prophet import Prophet
import statsmodels.api as sm
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.statespace.sarimax import SARIMAX
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from pandas.core.dtypes import dtypes
from sklearn.metrics import mean_squared_error
import numpy as np
from sklearn.metrics import mean_squared_error
from math import sqrt
import warnings
import logging
import logging

# Set up logging
logger_prophet = logging.getLogger('prophet')
logger_prophet.setLevel(logging.ERROR)
handler_prophet = logging.FileHandler('prophet_log.txt')
logger_prophet.addHandler(handler_prophet)

logger_cmdstanpy = logging.getLogger('cmdstanpy')
logger_cmdstanpy.setLevel(logging.ERROR)
handler_cmdstanpy = logging.FileHandler('cmdstanpy_log.txt')
logger_cmdstanpy.addHandler(handler_cmdstanpy)
logging.getLogger('prophet').setLevel(logging.ERROR)
logging.getLogger('cmdstanpy').setLevel(logging.ERROR)
warnings.filterwarnings('ignore')

#Load the data from csv file, also change column names removing any spaces, Conver columns to correct types
data = pd.read_csv(r'zimbabwe_final.csv',header=0)

data.rename(columns={'Zimbabwe - cases': 'zimbabwe_cases', 'Zimbabwe - deaths': 'Zimbabwe_deaths'}, inplace=True)

#Checking the first 5 rows of data to see how it looks like
data[['Year','Month','Day']].head(5)

data['date'] = pd.to_datetime(data[['Year', 'Month', 'Day']])

# Set the date column as index
data.set_index('date', inplace=True)

# Drop the original columns if they are no longer needed
data.drop(['Year', 'Month', 'Day'], axis=1, inplace=True)

# Check the data for any missing values or correct datatypes
data.info()

# Basic Descriptive Statistics
statistics = data.describe()
statistics.style.background_gradient(cmap='Greens')

# Histograms and Density Plots
data.hist(bins=30, figsize=(12, 6))
plt.suptitle('Histograms and Density Plots', x=0.5, y=1.02)
plt.show()

"""## **Distribution Analysis**
**Zimbabwe_cases:** We can see from the plots above that cases is distributed mostly at lower levels, such that majority of the cases are below 100 for a weekly basis.

**Zimbabwe_death:** For Zimbabwe_deaths mostly the deaths are in the ranges of 0-2 But there are cases where the death have gone up to 20 though these are not many, only 2-3 cases.

## **Relationship Plots - Bi-Variate Analysis**
"""

#Lets Define a function to plot scatter plots for our columns relationships
def scatter(column1: pd.Series, column2: pd.Series, x_label: str, y_label: str) -> None:
  """ Simple function to plot Scatter plots:
    params:
      column1: First column to be plotted on x axis
      column2: Second Column to be plotted on y-axis
      x_label: Label for x axis
      y_label: lable for y axis
    returns:
      Matplotlib Scatter Plot
  """
  plt.figure(figsize=(12, 6))
  plt.scatter(column1, column2)
  plt.title(f'Scatter Plot: {x_label} vs. {y_label}')
  plt.xlabel(f'{x_label}')
  plt.ylabel(f'{y_label}')
  plt.show()

# Scatter Plot for zimbabwe_cases and zimbabwe_deaths
scatter(data['zimbabwe_cases'],data['Zimbabwe_deaths'],'zimbabwe_cases', 'Zimbabwe_deaths')

# Scatter Plot for zimbabwe_cases and t2m
scatter(data['zimbabwe_cases'],data['T2M'],'zimbabwe_cases', 'T2M')

# Scatter Plot for Zimbabwe_deaths and t2m
scatter(data['Zimbabwe_deaths'],data['T2M'],'Zimbabwe_deaths', 'T2M')

# Scatter Plot for Zimbabwe_deaths and rfe
scatter(data['Zimbabwe_deaths'],data['PRECTOTCORR'],'Zimbabwe_deaths', 'PRECTOTCORR')

"""## **Correlation Analysis**"""

# Display the correlation matrix
correlation_matrix = data[1:].corr()

correlation_matrix

print("Correlation Matrix")
correlation_matrix.style.background_gradient(cmap='Greens')

"""## **Key Take Aways from Correlation Matrix**

**zimbabwe_cases and Zimbabwe_deaths**: There is a strong positive correlation (0.804055) between the number of cases and deaths in Zimbabwe. This suggests that as the number of cases increases, the number of deaths tends to increase as well.

**Temperature Variables (T2M, T2M_MAX, T2M_MIN)**:

T2M, T2M_MAX, and T2M_MIN are positively correlated with each other, with T2M and T2M_MAX showing a very strong correlation (0.924803). This indicates that the average temperature (T2M), maximum temperature (T2M_MAX), and minimum temperature (T2M_MIN) generally move in the same direction.
However, these temperature variables are negatively correlated with zimbabwe_cases and Zimbabwe_deaths, albeit weakly. This suggests that higher temperatures might be associated with fewer cases and deaths, but the relationship is not very strong.

**PRECTOTCORR (Precipitation):**

PRECTOTCORR shows a weak positive correlation with T2M_MIN (0.306413) and a very weak positive correlation with T2M (0.153029), implying that higher precipitation might be slightly associated with higher temperatures.
The correlation between PRECTOTCORR and zimbabwe_cases and Zimbabwe_deaths is very weak and negative (-0.059277 and -0.061243, respectively), indicating a negligible association.

**General Observations:**

The strongest correlations are found within the temperature variables themselves, indicating a strong internal consistency in temperature measurements.
The correlations between the health-related variables (zimbabwe_cases, Zimbabwe_deaths) and climatic variables (T2M, T2M_MAX, T2M_MIN, PRECTOTCORR) are relatively weak, suggesting that, according to this dataset, climate factors might not be strong predictors of cases and deaths in Zimbabwe.

## **Time Series plot for each of the variables**
"""

# Plotting each column in the dataset
fig, axes = plt.subplots(nrows=6, ncols=1, figsize=(14, 20))

columns = data.columns
for i, column in enumerate(columns):
    data[column].plot(ax=axes[i], title=column, legend=False)
    axes[i].set_ylabel(column)

plt.tight_layout()
plt.show()

"""The plots provide insights into the time series nature of the data. We observe the following:

**zimbabwe_cases:** There's a prominent upward trend with noticeable seasonality. Peaks are observed around mid-year.

**Zimbabwe_deaths:** Similar to zimbabwe_cases, it has an upward trend and seasonality.

**PRECTOTCORR:** This feature exhibits strong seasonality with peaks around mid-year.

**T2M, T2M_MAX, T2M_MIN:** These temperature-related features also have seasonality, but the pattern is different from the cases and deaths.

# **Analysis for Cases**

## ARIMA with DWT
"""

# Perform DWT on zimbabwe_cases to decompose it
coeffs = pywt.wavedec(data['zimbabwe_cases'], wavelet='db1', level=3)
cA3, cD3, cD2, cD1 = coeffs

# Plot the coefficients
fig, axes = plt.subplots(4, 1, figsize=(15, 12))

axes[0].plot(cA3, label="cA3 (Approximation Coefficients at Level 3)", color='blue')
axes[0].legend()
axes[0].set_title("cA3 (Approximation Coefficients at Level 3)")

axes[1].plot(cD3, label="cD3 (Detail Coefficients at Level 3)", color='green')
axes[1].legend()
axes[1].set_title("cD3 (Detail Coefficients at Level 3)")

axes[2].plot(cD2, label="cD2 (Detail Coefficients at Level 2)", color='red')
axes[2].legend()
axes[2].set_title("cD2 (Detail Coefficients at Level 2)")

axes[3].plot(cD1, label="cD1 (Detail Coefficients at Level 1)", color='purple')
axes[3].legend()
axes[3].set_title("cD1 (Detail Coefficients at Level 1)")

plt.tight_layout()
plt.show()

"""Here are the plots for the decomposition of the zimbabwe_cases time series using Discrete Wavelet Transform (DWT):

**cA3 (Approximation Coefficients at Level 3):** Represents the coarse approximation of the zimbabwe_cases time series.

**cD3, cD2, cD1 (Detail Coefficients at Levels 3, 2, and 1):** Capture the detailed information or high-frequency components of the zimbabwe_cases time series at various scales.

Next, we'll fit an ARIMA model on each of these decomposed series. Before doing so, we need to determine the optimal parameters (p, d, q) for the ARIMA model for each series. We'll start with the auto_arima function from the pmdarima library to find the best parameters. However, if the computation takes too long, we might need to simplify our approach.

Let's start by determining the ARIMA parameters for the cA3 coefficient series.


"""

#

from pmdarima import auto_arima

# Determine ARIMA parameters for cA3 series using auto_arima
arima_model_cA3 = auto_arima(cA3, seasonal=False, trace=True,
                             error_action='ignore', suppress_warnings=True,
                             stepwise=True)

# Display the best ARIMA parameters for cA3
arima_model_cA3.summary()

# Adjusting the number of lags for PACF
lags = len(cA3) // 2 - 1

fig, axes = plt.subplots(1, 2, figsize=(16, 4))

# Plot ACF
plot_acf(cA3, ax=axes[0], title="ACF for cA3")

# Plot PACF with adjusted lags
plot_pacf(cA3, ax=axes[1], lags=lags, title="PACF for cA3")

plt.tight_layout()
plt.show()

"""Here's the interpretation of the results From the ACF and PACF plots for the cA3:

**cA3 coefficient series:**

The ACF shows a gradual decline, indicating that the series might have a moving average (MA) component.
The PACF has a sharp cutoff after the first lag, suggesting an autoregressive (AR) order of 1.
Based on the plots, an initial estimate for the ARIMA parameters for the cA3 coefficient series might be
`(p=1,d=0,q=1)` or `(p=1,d=0,q=0)`.

We can fit an ARIMA model with these parameters and evaluate its performance. We'll start with the `(p=1,d=0,q=1)` parameters for the cA3 series.

## Applying ARIMA with DWT
"""

# Fit ARIMA model with parameters (p=1, d=0, q=1) on cA3 series
arima_cA3 = ARIMA(cA3, order=(1, 0, 1))
arima_cA3_fit = arima_cA3.fit()

# Display the model summary
arima_cA3_fit.summary()

"""In Simple Approach lets we'll make the following assumptions based on the insights gathered from the ACF and PACF plots of
cA3:

1.   Use the ARIMA parameters (p=1,d=0,q=0) for all the coefficient series.
2.   Forecast each coefficient series for the year 2024.
3.   Use the inverse wavelet transform to reconstruct the forecasted zimbabwe_cases for 2024.

Let's start by fitting ARIMA models with parameters
(p=1,d=0,q=0) for each coefficient series and then forecasting for 2024.
"""

# Define a function to fit ARIMA and forecast for the given series
def fit_and_forecast(series, forecast_periods):
    model = ARIMA(series, order=(1, 0, 0))
    model_fit = model.fit()
    forecast = model_fit.forecast(steps=forecast_periods)
    return forecast

# Number of forecast periods (for 2024)
forecast_periods = len(data['zimbabwe_cases']) // 62

# Forecast each coefficient series
forecast_cA3 = fit_and_forecast(cA3, forecast_periods)
forecast_cD3 = fit_and_forecast(cD3, forecast_periods)
forecast_cD2 = fit_and_forecast(cD2, forecast_periods)
forecast_cD1 = fit_and_forecast(cD1, forecast_periods)

forecast_cA3, forecast_cD3, forecast_cD2, forecast_cD1

# Obtain in-sample predictions
predicted_cA3 = arima_cA3_fit.predict()

# Calculate MSE
mse_arima = mean_squared_error(cA3, predicted_cA3)
print(f"Mean Squared Error for ARIMA with DWT model: {mse_arima}")

"""We have forecasted values for each coefficient series for the year 2024: cA3 forecast: Represents the coarse approximation.cD3,cD2,and cD1 forecasts: Represent details at different levels.
The next step is to use the inverse wavelet transform to reconstruct the forecasted zimbabwe_cases for 2024 using these forecasts. Let's perform this reconstruction.
"""

# Use inverse wavelet transform with only the approximation coefficients for reconstruction
reconstructed_forecast_simple = pywt.waverec([forecast_cA3, None, None, None], wavelet='db1')

# Plot the simplified reconstructed forecast
plt.figure(figsize=(14, 6))
plt.plot(reconstructed_forecast_simple, label='Forecasted zimbabwe_cases for 2024 (Simplified)', color='blue')
plt.title('Forecasted zimbabwe_cases for 2024 using ARIMA with DWT (Simplified)')
plt.legend()
plt.xlabel('Weeks of 2024')
plt.ylabel('zimbabwe_cases')
plt.show()

def plot_arima(column,lab):
  # Extract the original T2M data from 2019 to 2023

  original_data = column
  reconstructed_forecast_simple = pywt.waverec([forecast_cA3, None, None, None], wavelet='db1')

  # Combine the original data with the forecasted values
  combined_data = np.concatenate((original_data, reconstructed_forecast_simple))

  # Calculate number of weeks in the original data (excluding forecast)
  num_weeks_original = len(original_data)

  # Create x-axis tick positions and labels to indicate weeks of each year
  years = list(range(2019, 2024+1))
  tick_positions = [i * 52 for i in range(len(years))]
  tick_labels = [str(year) for year in years]

  # Plot the combined data with adjusted x-axis
  plt.figure(figsize=(16, 7))
  plt.plot(combined_data, label=f'{lab} (2019-2023) with Forecast (2024)', color='blue')
  plt.axvline(x=num_weeks_original-1, color='red', linestyle='--', label='Start of 2024 Forecast')
  plt.xticks(tick_positions, tick_labels)
  plt.title(f'{lab} from 2019 to 2023 and Forecast for 2024 using ARIMA with DWT')
  plt.legend()
  plt.xlabel('Weeks of Each Year')
  plt.ylabel(lab)
  plt.tight_layout()
  plt.show()

plot_arima(data['zimbabwe_cases'],'zimbabwe_cases')

"""## **Applying a Sarimax Model for zimbabwe_cases**

Augmented Dickey-Fuller test (ADF test) on the 'zimbabwe_cases' time series data. This test is commonly used to determine whether a time series is stationary or not.
"""

# Defining a Function for ADF test to check stationarity of the data
def ad_test(dataset):
     dftest = adfuller(dataset, autolag = 'AIC')
     print("1. ADF : ",dftest[0])
     print("2. P-Value : ", dftest[1])
     print("3. Num Of Lags : ", dftest[2])
     print("4. Num Of Observations Used For ADF Regression:",      dftest[3])
     print("5. Critical Values :")
     for key, val in dftest[4].items():
         print("\t",key, ": ", val)

ad_test(data['zimbabwe_cases'])

"""### Applying differencing to make series stationary"""

data['zimbabwe_cases_diff'] = data['zimbabwe_cases'].diff()
data.dropna(inplace=True)
result_diff = adfuller(data['zimbabwe_cases_diff'])
adf_stat_diff, p_value_diff = result_diff[0], result_diff[1]

adf_stat_diff, p_value_diff

# Lets try Sarimax also
sarimax_model_cases = SARIMAX(data['zimbabwe_cases'],order=(1,1,1), seasonal_order =(1,1,1,52))
sarimax_fit_cases = sarimax_model_cases.fit()
sarimax_fit_cases.summary()

#Extract AIC and BIC from SARIMAX model
sarimax_aic_cases = sarimax_fit_cases.aic
sarimax_bic_cases = sarimax_fit_cases.bic

sarimax_aic_cases, sarimax_bic_cases

#Generating SARIMAX Forecast
sarimax_forecast_cases =sarimax_fit_cases.get_forecast(steps=52)
sarimax_forecast_mean_cases = sarimax_forecast_cases.predicted_mean
sarimax_mse_cases = mean_squared_error(data['zimbabwe_cases'].iloc[-52:], sarimax_forecast_mean_cases)

#Generate forecast using SARIMAX
sarimax_forecast =sarimax_fit_cases.get_forecast(steps=52)
sarimax_forecast_mean = sarimax_forecast.predicted_mean

# Calculating mean suqared error(MSE) for the forecasts

sarimax_mse = mean_squared_error(data['zimbabwe_cases'].iloc[-52:], sarimax_forecast_mean)

#display the forecast metrics
plt.figure(figsize=(16, 8))

plt.plot(data['zimbabwe_cases'].iloc[-52:], label='Actual',color='blue')
#plotting SARIMAX forecast
plt.plot(data.index[-52:],sarimax_forecast_mean, label='SARIMAX Forecast',color ='green')

plt.xlabel('week_ending')
plt.ylabel('zimbabwe_cases')
plt.title('Forecast Comparisson between Actual and SARIMAX for zimbabwe_cases')
plt.legend()
plt.show()

# Plot the forecasts and confidence intervals for 'sarimax_forecast'

fig, ax = plt.subplots(figsize=(12, 6))
data['zimbabwe_cases'].plot(ax=ax, label='Observed',color='g')
sarimax_forecast_mean_cases.plot(ax=ax, label='SARIMAX Forecast', color='r')
ci_sarimax_cases = sarimax_forecast_cases.conf_int()
ax.fill_between(ci_sarimax_cases.index, ci_sarimax_cases.iloc[:, 0], ci_sarimax_cases.iloc[:, 1], color='pink',alpha=0.5)
ax.set_ylim(-500, 2500)
plt.title("SARIMAX Forecast for zimbabwe_cases for 2024")
plt.legend()
plt.show()

# Display the MSE
print("SARIMAX Mean Squared Error (MSE):", sarimax_mse_cases)

"""### **Prophet Model for zimbabwe_cases**"""

def prof(prophet_data):
  # Prepare the data for Prophet model


  # Initialize and train the Prophet model
  model_1 = Prophet()
  model_1.fit(prophet_data)

  # Predict for future (e.g., 365 days)
  future_1 = model_1.make_future_dataframe(periods=365)
  forecast_1 = model_1.predict(future_1)

  # Plotting
  fig_1 = model_1.plot(forecast_1)
  last_date = prophet_data['ds'].max()
  # Access the ax object and plot the observed data as a line
  ax = fig_1.gca()
  ax.plot(prophet_data['ds'], prophet_data['y'], 'pink', label='Observed data')

  # Highlight the forecast period with a vertical line
  last_date = prophet_data['ds'].max()
  ax.axvline(x=last_date, color='red', linestyle='--', label='End of historical data')

  plt.legend()
  plt.show()
  return forecast_1

name = input("What's your name? ")

file = open("names.txt", "w")
file.write(name)
file.close()

prophet_data = data.reset_index()
prophet_data.columns = ['ds', 'y', 'Zimbabwe_deaths', 'PRECTOTCORR', 'T2M', 'T2M_MAX', 'T2M_MIN','zimbabwe_cases_diff']
prophet_data = prophet_data[['ds', 'y']]
# Prepare data for Prophet
pr=prof(prophet_data)

forecasted_values_1 = pr['yhat'][:len(prophet_data)]
actual_values_1 = prophet_data['y']

# Calculate MSE
mse_1 = mean_squared_error(actual_values_1, forecasted_values_1)
print(f"Mean Squared Error for Scenario 1: {mse_1}")

"""### **Comparing the three models**"""

print(f"Mean Squared Error \nARIMA:   {mse_arima}\nSARIMAX: {sarimax_mse_cases}\nProphet: {mse_1}")

"""**The best model out of the three seems to be Prophet as it has the best MSE score and it has fitted perfectly to our data**

# **Analysis On Death Variable**

## ARIMA with DWT

### Even though Prophet seems to be the best model, lets try all three models for each variable
"""

# Perform DWT on zimbabwe_cases to decompose it
coeffs = pywt.wavedec(data['Zimbabwe_deaths'], wavelet='db1', level=3)
cA3, cD3, cD2, cD1 = coeffs

# Plot the coefficients
fig, axes = plt.subplots(4, 1, figsize=(15, 12))

axes[0].plot(cA3, label="cA3 (Approximation Coefficients at Level 3)", color='blue')
axes[0].legend()
axes[0].set_title("cA3 (Approximation Coefficients at Level 3)")

axes[1].plot(cD3, label="cD3 (Detail Coefficients at Level 3)", color='green')
axes[1].legend()
axes[1].set_title("cD3 (Detail Coefficients at Level 3)")

axes[2].plot(cD2, label="cD2 (Detail Coefficients at Level 2)", color='red')
axes[2].legend()
axes[2].set_title("cD2 (Detail Coefficients at Level 2)")

axes[3].plot(cD1, label="cD1 (Detail Coefficients at Level 1)", color='purple')
axes[3].legend()
axes[3].set_title("cD1 (Detail Coefficients at Level 1)")

plt.tight_layout()
plt.show()

# Determine ARIMA parameters for cA3 series using auto_arima
arima_model_cA3 = auto_arima(cA3, seasonal=False, trace=True,
                             error_action='ignore', suppress_warnings=True,
                             stepwise=True)

# Display the best ARIMA parameters for cA3
arima_model_cA3.summary()

# Adjusting the number of lags for PACF
lags = len(cA3) // 2 - 1

fig, axes = plt.subplots(1, 2, figsize=(16, 4))

# Plot ACF
plot_acf(cA3, ax=axes[0], title="ACF for cA3")

# Plot PACF with adjusted lags
plot_pacf(cA3, ax=axes[1], lags=lags, title="PACF for cA3")

plt.tight_layout()
plt.show()

# Fit ARIMA model with parameters (p=0, d=1, q=0) on cA3 series
arima_cA3 = ARIMA(cA3, order=(0, 1, 0))
arima_cA3_fit = arima_cA3.fit()

# Display the model summary
arima_cA3_fit.summary()

# Number of forecast periods (for 2024)
forecast_periods = len(data['Zimbabwe_deaths']) // 62

# Forecast each coefficient series
forecast_cA3 = fit_and_forecast(cA3, forecast_periods)
forecast_cD3 = fit_and_forecast(cD3, forecast_periods)
forecast_cD2 = fit_and_forecast(cD2, forecast_periods)
forecast_cD1 = fit_and_forecast(cD1, forecast_periods)

forecast_cA3, forecast_cD3, forecast_cD2, forecast_cD1

# Obtain in-sample predictions
predicted_cA3 = arima_cA3_fit.predict()

# Calculate MSE
mse_arima_deaths = mean_squared_error(cA3, predicted_cA3)
print(f"Mean Squared Error for ARIMA with DWT model: {mse_arima_deaths}")

# Use inverse wavelet transform with only the approximation coefficients for reconstruction
reconstructed_forecast_simple = pywt.waverec([forecast_cA3, None, None, None], wavelet='db1')

# Plot the simplified reconstructed forecast
plt.figure(figsize=(14, 6))
plt.plot(reconstructed_forecast_simple, label='Forecasted zimbabwe_cases for 2024 (Simplified)', color='blue')
plt.title('Forecasted zimbabwe_cases for 2024 using ARIMA with DWT (Simplified)')
plt.legend()
plt.xlabel('Weeks of 2024')
plt.ylabel('Zimbabwe_deaths')
plt.show()

plot_arima(data['Zimbabwe_deaths'],'Zimbabwe_deaths')

"""## **SARIMAX model for Zimbabwe_deaths**"""

# Lets try Sarimax also
sarimax_model_deaths = SARIMAX(data['Zimbabwe_deaths'],order=(1,1,1), seasonal_order =(1,1,1,52))
sarimax_fit_deaths = sarimax_model_deaths.fit()
sarimax_fit_deaths.summary()

#Extract AIC and BIC from ARIMA & SARIMAX model
sarimax_aic_deaths = sarimax_fit_deaths.aic
sarimax_bic_deaths = sarimax_fit_deaths.bic

sarimax_aic_deaths, sarimax_bic_deaths

# Plot the forecasts and confidence intervals for 'sarimax_forecast'
sarimax_forecast_deaths =sarimax_fit_deaths.get_forecast(steps=52)
sarimax_forecast_mean_deaths = sarimax_forecast_deaths.predicted_mean

fig, ax = plt.subplots(figsize=(12, 6))
data['Zimbabwe_deaths'].plot(ax=ax, label='Observed',color='g')
sarimax_forecast_mean_deaths.plot(ax=ax, label='SARIMAX Forecast', color='r')
ci_sarimax_deaths = sarimax_forecast_deaths.conf_int()
ax.fill_between(ci_sarimax_deaths.index, ci_sarimax_deaths.iloc[:, 0], ci_sarimax_deaths.iloc[:, 1], color='pink',alpha=0.5)
plt.title("SARIMAX Forecast for Zimbabwe_deaths for 2024")
plt.legend()
plt.show()

sarimax_mse_deaths = mean_squared_error(data['Zimbabwe_deaths'].iloc[-52:], sarimax_forecast_mean_deaths)
sarimax_mse_deaths

"""## **Prophet for Zimbabwe_deaths**"""

# Prepare the data for Prophet model
prophet_data = data.reset_index()
prophet_data.columns = ['ds', 'zimbabwe_cases', 'y', 'PRECTOTCORR', 'T2M', 'T2M_MAX', 'T2M_MIN','zimbabwe_cases_diff']
prophet_data = prophet_data[['ds', 'y']]
pr2=prof(prophet_data)

forecasted_values_1 = pr2['yhat'][:len(prophet_data)]
actual_values_1 = prophet_data['y']

# Calculate MSE
mse_2 = mean_squared_error(actual_values_1, forecasted_values_1)
print(f"Mean Squared Error for Scenario 1: {mse_2}")

print(f"Mean Squared Error \nARIMA:   {mse_arima_deaths}\nSARIMAX: {sarimax_mse_deaths}\nProphet: {mse_2}")

"""### **Again we can see that the best model out of the three is the Prophet model**

# **Analysis on PRECTOTCORR**

### **ARIMA with DWT on PRECTOTCORR**
"""

# Perform DWT on zimbabwe_cases to decompose it
coeffs = pywt.wavedec(data['PRECTOTCORR'], wavelet='db1', level=3)
cA3, cD3, cD2, cD1 = coeffs

# Plot the coefficients
fig, axes = plt.subplots(4, 1, figsize=(15, 12))

axes[0].plot(cA3, label="cA3 (Approximation Coefficients at Level 3)", color='blue')
axes[0].legend()
axes[0].set_title("cA3 (Approximation Coefficients at Level 3)")

axes[1].plot(cD3, label="cD3 (Detail Coefficients at Level 3)", color='green')
axes[1].legend()
axes[1].set_title("cD3 (Detail Coefficients at Level 3)")

axes[2].plot(cD2, label="cD2 (Detail Coefficients at Level 2)", color='red')
axes[2].legend()
axes[2].set_title("cD2 (Detail Coefficients at Level 2)")

axes[3].plot(cD1, label="cD1 (Detail Coefficients at Level 1)", color='purple')
axes[3].legend()
axes[3].set_title("cD1 (Detail Coefficients at Level 1)")

plt.tight_layout()
plt.show()

# Determine ARIMA parameters for cA3 series using auto_arima
arima_model_cA3 = auto_arima(cA3, seasonal=False, trace=True,
                             error_action='ignore', suppress_warnings=True,
                             stepwise=True)

# Display the best ARIMA parameters for cA3
arima_model_cA3.summary()

# Adjusting the number of lags for PACF
lags = len(cA3) // 2 - 1

fig, axes = plt.subplots(1, 2, figsize=(16, 4))

# Plot ACF
plot_acf(cA3, ax=axes[0], title="ACF for cA3")

# Plot PACF with adjusted lags
plot_pacf(cA3, ax=axes[1], lags=lags, title="PACF for cA3")

plt.tight_layout()
plt.show()

# Fit ARIMA model with parameters (p=0, d=1, q=0) on cA3 series
arima_cA3 = ARIMA(cA3, order=(0, 1, 0))
arima_cA3_fit = arima_cA3.fit()

# Display the model summary
arima_cA3_fit.summary()

# Number of forecast periods (for 2024)
forecast_periods = len(data['PRECTOTCORR']) // 62

# Forecast each coefficient series
forecast_cA3 = fit_and_forecast(cA3, forecast_periods)
forecast_cD3 = fit_and_forecast(cD3, forecast_periods)
forecast_cD2 = fit_and_forecast(cD2, forecast_periods)
forecast_cD1 = fit_and_forecast(cD1, forecast_periods)

forecast_cA3, forecast_cD3, forecast_cD2, forecast_cD1

# Obtain in-sample predictions
predicted_cA3 = arima_cA3_fit.predict()

# Calculate MSE
mse_arima_PRECTOTCORR = mean_squared_error(cA3, predicted_cA3)
print(f"Mean Squared Error for ARIMA with DWT model: {mse_arima_PRECTOTCORR}")

plot_arima(data['PRECTOTCORR'],'PRECTOTCORR')

"""## **SARIMAX for PRECTOTCORR**"""

# Lets try Sarimax also
sarimax_model_PRECTOTCORR = SARIMAX(data['PRECTOTCORR'],order=(1,1,1), seasonal_order =(1,1,1,52))
sarimax_fit_PRECTOTCORR = sarimax_model_PRECTOTCORR.fit()
sarimax_fit_PRECTOTCORR.summary()

#Extract AIC and BIC from ARIMA & SARIMAX model
sarimax_aic_PRECTOTCORR = sarimax_fit_PRECTOTCORR.aic
sarimax_bic_PRECTOTCORR = sarimax_fit_PRECTOTCORR.bic

sarimax_aic_PRECTOTCORR, sarimax_bic_PRECTOTCORR

# Plot the forecasts and confidence intervals for 'sarimax_forecast'
sarimax_forecast_PRECTOTCORR =sarimax_fit_PRECTOTCORR.get_forecast(steps=52)
sarimax_forecast_mean_PRECTOTCORR = sarimax_forecast_PRECTOTCORR.predicted_mean

fig, ax = plt.subplots(figsize=(12, 6))
data['PRECTOTCORR'].plot(ax=ax, label='Observed',color='g')
sarimax_forecast_mean_PRECTOTCORR.plot(ax=ax, label='SARIMAX Forecast', color='r')
ci_sarimax_PRECTOTCORR = sarimax_forecast_PRECTOTCORR.conf_int()
ax.fill_between(ci_sarimax_PRECTOTCORR.index, ci_sarimax_PRECTOTCORR.iloc[:, 0], ci_sarimax_PRECTOTCORR.iloc[:, 1], color='pink',alpha=0.5)
plt.title("SARIMAX Forecast for PRECTOTCORR for 2024")
plt.legend()
plt.show()

PRECTOTCORR = mean_squared_error(data['PRECTOTCORR'].iloc[-52:], sarimax_forecast_mean_PRECTOTCORR)
PRECTOTCORR

"""## **Prophet on Prectotcorr**"""

# Prepare the data for Prophet model
prophet_data = data.reset_index()
prophet_data.columns = ['ds', 'zimbabwe_cases', 'Zimbabwe_deaths', 'y', 'T2M', 'T2M_MAX', 'T2M_MIN','zimbabwe_cases_diff']
prophet_data = prophet_data[['ds', 'y']]
# Prepare data for Prophet
pr3=prof(prophet_data)

forecasted_values_1 = pr3['yhat'][:len(prophet_data)]
actual_values_1 = prophet_data['y']

# Calculate MSE
mse_3 = mean_squared_error(actual_values_1, forecasted_values_1)
print(f"Mean Squared Error for Scenario 1: {mse_3}")

print(f"Mean Squared Error \nARIMA:   {mse_arima_PRECTOTCORR}\nSARIMAX: {PRECTOTCORR}\nProphet: {mse_3}")

"""# **Analysis on T2M**"""

# Perform DWT on zimbabwe_cases to decompose it
coeffs = pywt.wavedec(data['T2M'], wavelet='db1', level=3)
cA3, cD3, cD2, cD1 = coeffs

# Plot the coefficients
fig, axes = plt.subplots(4, 1, figsize=(15, 12))

axes[0].plot(cA3, label="cA3 (Approximation Coefficients at Level 3)", color='blue')
axes[0].legend()
axes[0].set_title("cA3 (Approximation Coefficients at Level 3)")

axes[1].plot(cD3, label="cD3 (Detail Coefficients at Level 3)", color='green')
axes[1].legend()
axes[1].set_title("cD3 (Detail Coefficients at Level 3)")

axes[2].plot(cD2, label="cD2 (Detail Coefficients at Level 2)", color='red')
axes[2].legend()
axes[2].set_title("cD2 (Detail Coefficients at Level 2)")

axes[3].plot(cD1, label="cD1 (Detail Coefficients at Level 1)", color='purple')
axes[3].legend()
axes[3].set_title("cD1 (Detail Coefficients at Level 1)")

plt.tight_layout()
plt.show()

# Determine ARIMA parameters for cA3 series using auto_arima
arima_model_cA3 = auto_arima(cA3, seasonal=False, trace=True,
                             error_action='ignore', suppress_warnings=True,
                             stepwise=True)

# Display the best ARIMA parameters for cA3
arima_model_cA3.summary()

# Adjusting the number of lags for PACF
lags = len(cA3) // 2 - 1

fig, axes = plt.subplots(1, 2, figsize=(16, 4))

# Plot ACF
plot_acf(cA3, ax=axes[0], title="ACF for cA3")

# Plot PACF with adjusted lags
plot_pacf(cA3, ax=axes[1], lags=lags, title="PACF for cA3")

plt.tight_layout()
plt.show()

# Fit ARIMA model with parameters (p=0, d=1, q=0) on cA3 series
arima_cA3 = ARIMA(cA3, order=(0, 1, 0))
arima_cA3_fit = arima_cA3.fit()

# Display the model summary
arima_cA3_fit.summary()

# Number of forecast periods (for 2024)
forecast_periods = len(data['T2M']) // 62

# Forecast each coefficient series
forecast_cA3 = fit_and_forecast(cA3, forecast_periods)
forecast_cD3 = fit_and_forecast(cD3, forecast_periods)
forecast_cD2 = fit_and_forecast(cD2, forecast_periods)
forecast_cD1 = fit_and_forecast(cD1, forecast_periods)

forecast_cA3, forecast_cD3, forecast_cD2, forecast_cD1

# Obtain in-sample predictions
predicted_cA3 = arima_cA3_fit.predict()

# Calculate MSE
mse_arima_T2M = mean_squared_error(cA3, predicted_cA3)
print(f"Mean Squared Error for ARIMA with DWT model: {mse_arima_T2M}")

plot_arima(data['T2M'],'T2M')

"""## **SARIMAX for T2M**"""

# Lets try Sarimax also
sarimax_model_T2M = SARIMAX(data['T2M'],order=(1,1,1), seasonal_order =(1,1,1,52))
sarimax_fit_T2M = sarimax_model_T2M.fit()
sarimax_fit_T2M.summary()

#Extract AIC and BIC from ARIMA & SARIMAX model
sarimax_aic_T2M = sarimax_fit_T2M.aic
sarimax_bic_T2M = sarimax_fit_T2M.bic

sarimax_aic_T2M, sarimax_bic_T2M

# Plot the forecasts and confidence intervals for 'sarimax_forecast'
sarimax_forecast_T2M =sarimax_fit_T2M.get_forecast(steps=52)
sarimax_forecast_mean_T2M = sarimax_forecast_T2M.predicted_mean

fig, ax = plt.subplots(figsize=(12, 6))
data['T2M'].plot(ax=ax, label='Observed',color='g')
sarimax_forecast_mean_T2M.plot(ax=ax, label='SARIMAX Forecast', color='r')
ci_sarimax_T2M = sarimax_forecast_T2M.conf_int()
ax.fill_between(ci_sarimax_T2M.index, ci_sarimax_T2M.iloc[:, 0], ci_sarimax_T2M.iloc[:, 1], color='pink',alpha=0.5)
plt.title("SARIMAX Forecast for T2M for 2024")
plt.legend()
plt.show()

SARIMAX_T2M_MSE = mean_squared_error(data['T2M'].iloc[-52:], sarimax_forecast_mean_T2M)
SARIMAX_T2M_MSE

"""## **Prophet for T2M**"""

# Prepare the data for Prophet model
prophet_data = data.reset_index()
prophet_data.columns = ['ds', 'zimbabwe_cases', 'Zimbabwe_deaths', 'PRECTOTCORR', 'y', 'T2M_MAX', 'T2M_MIN','DRC_cases_diff']
prophet_data = prophet_data[['ds', 'y']]
# Prepare data for Prophet

pr4=prof(prophet_data)

forecasted_values_1 = pr4['yhat'][:len(prophet_data)]
actual_values_1 = prophet_data['y']

# Calculate MSE
mse_4 = mean_squared_error(actual_values_1, forecasted_values_1)
print(f"Mean Squared Error for Scenario 1: {mse_4}")

print(f"Mean Squared Error \nARIMA:   {mse_arima_T2M}\nSARIMAX: {SARIMAX_T2M_MSE}\nProphet: {mse_4}")

"""### **Again the best model here seems to be Prophet**

# **Analysis on T2M_MAX**

## **ARIMA with DWT on T2M_MAX**
"""

# Perform DWT on zimbabwe_cases to decompose it
coeffs = pywt.wavedec(data['T2M_MAX'], wavelet='db1', level=3)
cA3, cD3, cD2, cD1 = coeffs

# Plot the coefficients
fig, axes = plt.subplots(4, 1, figsize=(15, 12))

axes[0].plot(cA3, label="cA3 (Approximation Coefficients at Level 3)", color='blue')
axes[0].legend()
axes[0].set_title("cA3 (Approximation Coefficients at Level 3)")

axes[1].plot(cD3, label="cD3 (Detail Coefficients at Level 3)", color='green')
axes[1].legend()
axes[1].set_title("cD3 (Detail Coefficients at Level 3)")

axes[2].plot(cD2, label="cD2 (Detail Coefficients at Level 2)", color='red')
axes[2].legend()
axes[2].set_title("cD2 (Detail Coefficients at Level 2)")

axes[3].plot(cD1, label="cD1 (Detail Coefficients at Level 1)", color='purple')
axes[3].legend()
axes[3].set_title("cD1 (Detail Coefficients at Level 1)")

plt.tight_layout()
plt.show()

# Determine ARIMA parameters for cA3 series using auto_arima
arima_model_cA3 = auto_arima(cA3, seasonal=False, trace=True,
                             error_action='ignore', suppress_warnings=True,
                             stepwise=True)

# Display the best ARIMA parameters for cA3
arima_model_cA3.summary()

# Adjusting the number of lags for PACF
lags = len(cA3) // 2 - 1

fig, axes = plt.subplots(1, 2, figsize=(16, 4))

# Plot ACF
plot_acf(cA3, ax=axes[0], title="ACF for cA3")

# Plot PACF with adjusted lags
plot_pacf(cA3, ax=axes[1], lags=lags, title="PACF for cA3")

plt.tight_layout()
plt.show()

# Number of forecast periods (for 2024)
forecast_periods = len(data['T2M_MAX']) // 62

# Forecast each coefficient series
forecast_cA3 = fit_and_forecast(cA3, forecast_periods)
forecast_cD3 = fit_and_forecast(cD3, forecast_periods)
forecast_cD2 = fit_and_forecast(cD2, forecast_periods)
forecast_cD1 = fit_and_forecast(cD1, forecast_periods)

forecast_cA3, forecast_cD3, forecast_cD2, forecast_cD1

# Obtain in-sample predictions
predicted_cA3 = arima_cA3_fit.predict()

# Calculate MSE
mse_arima_T2M_MAX = mean_squared_error(cA3, predicted_cA3)
print(f"Mean Squared Error for ARIMA with DWT model: {mse_arima_T2M_MAX}")

plot_arima(data['T2M_MAX'],'T2M_MAX')

"""## **SARIMAX on T2M_MAX**"""

# Lets try Sarimax also
sarimax_model_T2M_MAX = SARIMAX(data['T2M_MAX'],order=(1,1,1), seasonal_order =(1,1,1,52))
sarimax_fit_T2M_MAX = sarimax_model_T2M_MAX.fit()
sarimax_fit_T2M_MAX.summary()

#Extract AIC and BIC from ARIMA & SARIMAX model
sarimax_aic_T2M_MAX = sarimax_fit_T2M_MAX.aic
sarimax_bic_T2M_MAX = sarimax_fit_T2M_MAX.bic

sarimax_aic_T2M_MAX, sarimax_bic_T2M_MAX

# Plot the forecasts and confidence intervals for 'sarimax_forecast'
sarimax_forecast_T2M_MAX =sarimax_fit_T2M_MAX.get_forecast(steps=52)
sarimax_forecast_mean_T2M_MAX = sarimax_forecast_T2M_MAX.predicted_mean

fig, ax = plt.subplots(figsize=(12, 6))
data['T2M_MAX'].plot(ax=ax, label='Observed',color='g')
sarimax_forecast_mean_T2M_MAX.plot(ax=ax, label='SARIMAX Forecast', color='r')
ci_sarimax_T2M_MAX = sarimax_forecast_T2M_MAX.conf_int()
ax.fill_between(ci_sarimax_T2M_MAX.index, ci_sarimax_T2M_MAX.iloc[:, 0], ci_sarimax_T2M_MAX.iloc[:, 1], color='pink',alpha=0.5)
plt.title("SARIMAX Forecast for T2M_MAX for 2024")
plt.legend()
plt.show()

SARIMAX_T2M_MAX_MSE = mean_squared_error(data['T2M_MAX'].iloc[-52:], sarimax_forecast_mean_T2M_MAX)
SARIMAX_T2M_MAX_MSE

"""## **Prophet on T2M_MAX**"""

prophet_data = data.reset_index()
prophet_data.columns = ['ds', 'zimbabwe_cases', 'Zimbabwe_deaths', 'PRECTOTCORR', 'T2M', 'y', 'T2M_MIN','zimbabwe_cases_diff']
prophet_data = prophet_data[['ds', 'y']]

pr5=prof(prophet_data)

forecasted_values_1 = pr5['yhat'][:len(prophet_data)]
actual_values_1 = prophet_data['y']

# Calculate MSE
mse_5 = mean_squared_error(actual_values_1, forecasted_values_1)
print(f"Mean Squared Error for Prophet T2M_MAX: {mse_5}")

print(f"Mean Squared Error \nARIMA:   {mse_arima_T2M_MAX}\nSARIMAX: {SARIMAX_T2M_MAX_MSE}\nProphet: {mse_5}")

"""## Prophet outperforms the other two models for T2M_MAX

# **Analysis on T2M_MIN**

## ARIMA with DWT on T2M_MIN
"""

## Perform DWT on zimbabwe_cases to decompose it
coeffs = pywt.wavedec(data['T2M_MIN'], wavelet='db1', level=3)
cA3, cD3, cD2, cD1 = coeffs

# Plot the coefficients
fig, axes = plt.subplots(4, 1, figsize=(15, 12))

axes[0].plot(cA3, label="cA3 (Approximation Coefficients at Level 3)", color='blue')
axes[0].legend()
axes[0].set_title("cA3 (Approximation Coefficients at Level 3)")

axes[1].plot(cD3, label="cD3 (Detail Coefficients at Level 3)", color='green')
axes[1].legend()
axes[1].set_title("cD3 (Detail Coefficients at Level 3)")

axes[2].plot(cD2, label="cD2 (Detail Coefficients at Level 2)", color='red')
axes[2].legend()
axes[2].set_title("cD2 (Detail Coefficients at Level 2)")

axes[3].plot(cD1, label="cD1 (Detail Coefficients at Level 1)", color='purple')
axes[3].legend()
axes[3].set_title("cD1 (Detail Coefficients at Level 1)")

plt.tight_layout()
plt.show()

# Determine ARIMA parameters for cA3 series using auto_arima
arima_model_cA3 = auto_arima(cA3, seasonal=False, trace=True,
                             error_action='ignore', suppress_warnings=True,
                             stepwise=True)

# Display the best ARIMA parameters for cA3
arima_model_cA3.summary()

# Adjusting the number of lags for PACF
lags = len(cA3) // 2 - 1

fig, axes = plt.subplots(1, 2, figsize=(16, 4))

# Plot ACF
plot_acf(cA3, ax=axes[0], title="ACF for cA3")

# Plot PACF with adjusted lags
plot_pacf(cA3, ax=axes[1], lags=lags, title="PACF for cA3")

plt.tight_layout()
plt.show()

# Number of forecast periods (for 2024)
forecast_periods = len(data['T2M_MIN']) // 62

# Forecast each coefficient series
forecast_cA3 = fit_and_forecast(cA3, forecast_periods)
forecast_cD3 = fit_and_forecast(cD3, forecast_periods)
forecast_cD2 = fit_and_forecast(cD2, forecast_periods)
forecast_cD1 = fit_and_forecast(cD1, forecast_periods)

forecast_cA3, forecast_cD3, forecast_cD2, forecast_cD1

# Obtain in-sample predictions
predicted_cA3 = arima_cA3_fit.predict()

# Calculate MSE
mse_arima_T2M_MIN = mean_squared_error(cA3, predicted_cA3)
print(f"Mean Squared Error for ARIMA with DWT model: {mse_arima_T2M_MIN}")

plot_arima(data['T2M_MIN'],'T2M_MIN')

"""## **SARIMAX for T2M_MIN**"""

# Lets try Sarimax also
sarimax_model_T2M_MIN = SARIMAX(data['T2M_MIN'],order=(1,1,1), seasonal_order =(1,1,1,52))
sarimax_fit_T2M_MIN = sarimax_model_T2M_MIN.fit()
sarimax_fit_T2M_MIN.summary()

#Extract AIC and BIC from ARIMA & SARIMAX model
sarimax_aic_T2M_MIN = sarimax_fit_T2M_MIN.aic
sarimax_bic_T2M_MIN = sarimax_fit_T2M_MIN.bic

sarimax_aic_T2M_MIN, sarimax_bic_T2M_MIN

# Plot the forecasts and confidence intervals for 'sarimax_forecast'
sarimax_forecast_T2M_MIN =sarimax_fit_T2M_MIN.get_forecast(steps=52)
sarimax_forecast_mean_T2M_MIN = sarimax_forecast_T2M_MIN.predicted_mean

fig, ax = plt.subplots(figsize=(12, 6))
data['T2M_MIN'].plot(ax=ax, label='Observed',color='g')
sarimax_forecast_mean_T2M_MIN.plot(ax=ax, label='SARIMAX Forecast', color='r')
ci_sarimax_T2M_MIN = sarimax_forecast_T2M_MIN.conf_int()
ax.fill_between(ci_sarimax_T2M_MIN.index, ci_sarimax_T2M_MIN.iloc[:, 0], ci_sarimax_T2M_MIN.iloc[:, 1], color='pink',alpha=0.5)
plt.title("SARIMAX Forecast for T2M_MIN for 2024")
plt.legend()
plt.show()

SARIMAX_T2M_MIN_MSE = mean_squared_error(data['T2M_MIN'].iloc[-52:], sarimax_forecast_mean_T2M_MIN)
SARIMAX_T2M_MIN_MSE

"""## **Prophet Model on T2M_MIN**"""

prophet_data = data.reset_index()
prophet_data.columns = ['ds', 'zimbabwe_cases', 'Zimbabwe_deaths', 'PRECTOTCORR', 'T2M', 'T2M_MAX', 'y','zimbabwe_cases_diff']
prophet_data = prophet_data[['ds', 'y']]

pr6=prof(prophet_data)

forecasted_values_1 = pr6['yhat'][:len(prophet_data)]
actual_values_1 = prophet_data['y']

# Calculate MSE
mse_6 = mean_squared_error(actual_values_1, forecasted_values_1)
print(f"Mean Squared Error for Prophet T2M_MAX: {mse_6}")

print(f"Mean Squared Error \nARIMA:   {mse_arima_T2M_MIN}\nSARIMAX: {SARIMAX_T2M_MIN_MSE}\nProphet: {mse_6}")

"""# All Prophet Models in a single chart"""

# Updated list of columns to forecast
columns_to_forecast = ['zimbabwe_cases','PRECTOTCORR','Zimbabwe_deaths', 'T2M', 'T2M_MAX', 'T2M_MIN']
# List of colors for plotting
colors = ['blue',  'purple', 'orange','cyan','brown','green',]
df=data.reset_index()
forecast_dfs={}
plt.figure(figsize=(15, 8))
for idx, col in enumerate(columns_to_forecast):
    prophet_data = df[['date', col]].copy()  # Create a deep copy of the subset
    prophet_data.columns = ['ds', 'target']  # Rename columns

    # Now, only rename 'target' to 'y'
    prophet_data = prophet_data.rename(columns={'target': 'y'})

    model = Prophet(weekly_seasonality=False)
    model.fit(prophet_data)

    future = model.make_future_dataframe(periods=365)  # This ensures at least one year
    forecast = model.predict(future)
    # Create a new DataFrame for the forecast
    forecast_df = forecast[['ds', 'yhat']].copy()
    forecast_df.columns = ['Date', f'Forecast_{col}']

    # Store the forecast DataFrame in the dictionary
    forecast_dfs[col] = forecast_df
    # Plot the forecast
    plt.plot(forecast['ds'], forecast['yhat'], color=colors[idx], label=f'Forecast {col}')

    # Plot the observed data with the same color
    plt.plot(df['date'], df[col], color=colors[idx], linestyle='--', label=f'Observed {col}')

# Determine start and end years
start_year = df['date'].dt.year.min()
end_year = forecast['ds'].dt.year.max()

# Create a date range for quarters of all years in the data range
date_range = pd.date_range(start=f"{start_year}-01-01", end=f"{end_year}-12-31", freq='Q')

# Adjust the labels to display year and quarter
labels = [f'Q{((month - 1) // 3) + 1} {year}' for year, month in zip(date_range.year, date_range.month)]
last_date = df['date'].max()

plt.xticks(ticks=date_range, labels=labels, rotation=45)
plt.axvline(x=last_date, color='red', linestyle='--', label='End of historical data')

# Set x-axis limits
plt.xlim(date_range.min(), date_range.max())

# Adjust layout for better display
plt.tight_layout()

plt.legend()
plt.show()
for col, forecast_df in forecast_dfs.items():
    forecast_df.to_csv(f'forecast_{col}.csv', index=False)

"""### Plots with just Deaths,T2M,T2M_MAX,T2M_MIN
The reason being they are not at the same y scale as cases
"""

# Updated list of columns to forecast
columns_to_forecast = ['Zimbabwe_deaths', 'T2M', 'T2M_MAX', 'T2M_MIN']
#'zimbabwe_cases',  'green','PRECTOTCORR','brown',
# List of colors for plotting
colors = ['blue',  'purple', 'orange','cyan']
df=data.reset_index()

plt.figure(figsize=(15, 8))
for idx, col in enumerate(columns_to_forecast):
    prophet_data = df[['date', col]].copy()  # Create a deep copy of the subset
    prophet_data.columns = ['ds', 'target']  # Rename columns

    # Now, only rename 'target' to 'y'
    prophet_data = prophet_data.rename(columns={'target': 'y'})

    model = Prophet(weekly_seasonality=False)
    model.fit(prophet_data)

    future = model.make_future_dataframe(periods=365)  # This ensures at least one year
    forecast = model.predict(future)

    # Plot the forecast
    plt.plot(forecast['ds'], forecast['yhat'], color=colors[idx], label=f'Forecast {col}')

    # Plot the observed data with the same color
    plt.plot(df['date'], df[col], color=colors[idx], linestyle='--', label=f'Observed {col}')

# Determine start and end years
start_year = df['date'].dt.year.min()
end_year = forecast['ds'].dt.year.max()

# Create a date range for quarters of all years in the data range
date_range = pd.date_range(start=f"{start_year}-01-01", end=f"{end_year}-12-31", freq='Q')

# Adjust the labels to display year and quarter
labels = [f'Q{((month - 1) // 3) + 1} {year}' for year, month in zip(date_range.year, date_range.month)]
last_date = df['date'].max()

plt.xticks(ticks=date_range, labels=labels, rotation=45)
plt.axvline(x=last_date, color='red', linestyle='--', label='End of historical data')

# Set x-axis limits
plt.xlim(date_range.min(), date_range.max())

# Adjust layout for better display
plt.tight_layout()

plt.legend()
plt.show()

"""### Plot with just DRC-cases & PRECTOTCORR"""

# Updated list of columns to forecast
columns_to_forecast = ['zimbabwe_cases','PRECTOTCORR']
# List of colors for plotting
colors = ['blue',  'purple']
df=data.reset_index()

plt.figure(figsize=(15, 8))
for idx, col in enumerate(columns_to_forecast):
    prophet_data = df[['date', col]].copy()  # Create a deep copy of the subset
    prophet_data.columns = ['ds', 'target']  # Rename columns

    # Now, only rename 'target' to 'y'
    prophet_data = prophet_data.rename(columns={'target': 'y'})

    model = Prophet(weekly_seasonality=False)
    model.fit(prophet_data)

    future = model.make_future_dataframe(periods=365)  # This ensures at least one year
    forecast = model.predict(future)

    # Plot the forecast
    plt.plot(forecast['ds'], forecast['yhat'], color=colors[idx], label=f'Forecast {col}')

    # Plot the observed data with the same color
    plt.plot(df['date'], df[col], color=colors[idx], linestyle='--', label=f'Observed {col}')

# Determine start and end years
start_year = df['date'].dt.year.min()
end_year = forecast['ds'].dt.year.max()

# Create a date range for quarters of all years in the data range
date_range = pd.date_range(start=f"{start_year}-01-01", end=f"{end_year}-12-31", freq='Q')

# Adjust the labels to display year and quarter
labels = [f'Q{((month - 1) // 3) + 1} {year}' for year, month in zip(date_range.year, date_range.month)]
last_date = df['date'].max()

plt.xticks(ticks=date_range, labels=labels, rotation=45)
plt.axvline(x=last_date, color='red', linestyle='--', label='End of historical data')

# Set x-axis limits
plt.xlim(date_range.min(), date_range.max())

# Adjust layout for better display
plt.tight_layout()

plt.legend()
plt.show()

# @title

from sklearn.metrics import mean_absolute_error

# Load the dataset
data = df



# Define columns to forecast and color scheme
columns_to_forecast = ['zimbabwe_cases', 'Zimbabwe_deaths', 'PRECTOTCORR', 'T2M', 'T2M_MAX', 'T2M_MIN']
colors = ['blue', 'green', 'red', 'cyan', 'magenta', 'yellow']

# Split the data into training (up to 2022) and testing (2023 up to September)
train_df = df[df['date'].dt.year < 2023]
test_df = df[(df['date'].dt.year == 2023) & (df['date'].dt.month <= 8)]

# Prepare for plotting
plt.figure(figsize=(15, 8))

# Initialize dictionaries to store metrics
mae_values = {}
accuracy_values = {}
epsilon = 1e-4
forecast_dfs = {}
# Loop through each column to forecast and calculate metrics
for idx, col in enumerate(columns_to_forecast):
    # Preparing data for Prophet
    prophet_data = train_df[['date', col]].copy()
    prophet_data.columns = ['ds', 'y']

    # Fitting the Prophet model
    model = Prophet(weekly_seasonality=True)
    model.fit(prophet_data)

 # Make a future dataframe until the last date of the actual data in 2023
    last_actual_date = test_df['date'].max()
    future = model.make_future_dataframe(periods=(last_actual_date - train_df['date'].max()).days)
    forecast = model.predict(future)

    # Extract forecasted values for January to September 2023
    forecast_2023 = forecast[forecast['ds'].isin(test_df['date'])]['yhat']

    actual_2023 = test_df[col]
    # Create a new DataFrame for the forecast
    forecast_df = forecast[['ds', 'yhat']].copy()
    forecast_df.columns = ['Date', f'Forecast_{col}']

    # Store the forecast DataFrame in the dictionary
    forecast_dfs[col] = forecast_df
    # Calculate MAE and accuracy (using MAPE)

    mae = mean_absolute_error(actual_2023, forecast_2023)
    mape = np.mean(np.abs((actual_2023 - forecast_2023) / (actual_2023 + epsilon))) * 100
    accuracy = 100 - mape

    # Store results
    mae_values[col] = mae
    accuracy_values[col] = accuracy

    # Plotting the forecast and actual values
    plt.plot(forecast['ds'], forecast['yhat'], color=colors[idx], label=f'Forecast {col}')
    plt.plot(train_df['date'], train_df[col], color=colors[idx], linestyle='--', label=f'Observed {col}')

# Finalize plot settings
plt.legend()
plt.xlabel("Date")
plt.ylabel("Values")
plt.title("Forecast vs Actual Data")
plt.show()

for col, forecast_df in forecast_dfs.items():
    forecast_df.to_csv(f'forecast_{col}.csv', index=False)
# Display the MAE and accuracy values
print("MAE Values:", mae_values)
print("Accuracy Values:", accuracy_values)

def calculate_mase(actual_series, forecast_series, seasonal_period):
    """
    Calculate Mean Absolute Scaled Error (MASE)
    """
    n = len(actual_series)
    d = np.abs(np.diff(actual_series)).sum() / (n - 1)

    errors = np.abs(actual_series - forecast_series)
    mase = errors.mean() / d
    return mase

# Initialize dictionary to store MASE
mase_values = {}

# Loop through each column to calculate MASE
for col in columns_to_forecast:
    # Assuming no strong seasonality in the data; we use previous value as the naïve forecast.
    # For different types of data, this seasonality might need to be adjusted.
    mase = calculate_mase(test_df[col], forecast_2023, seasonal_period=1)
    mase_values[col] = mase

print("MASE Values:", mase_values)

"""#### **Displaying the Mean Squared Errors and Root Mean Squared errors for all Prophet Models**"""

# @title
mse_values = {
    'zimbabwe_cases': 1.84,
    'Zimbabwe_deaths': 3.48,
    'PRECTOTCORR': 14.92,
    'T2M': 2.52,
    'T2M_MAX': 4.29,
    'T2M_MIN': 2.81
}
mae_values = {
    'zimbabwe_cases': 120.34,
    'Zimbabwe_deaths': 3.014,
    'PRECTOTCORR': 1.25,
    'T2M': 2.30,
    'T2M_MAX': 3.34,
    'T2M_MIN': 1.72
}
accuracy = {
    'zimbabwe_cases': '-',
    'Zimbabwe_deaths': '-',
    'PRECTOTCORR': '43.9%',
    'T2M': '67.52%',
    'T2M_MAX': '79.46%',
    'T2M_MIN': '34.84%'
}
# Calculate RMSE values
rmse_values = {key: np.sqrt(value) for key, value in mse_values.items()}

# Create a dataframe to display the results
results_df = pd.DataFrame({
    'Variable': mse_values.keys(),
    'MSE': mse_values.values(),
    'RMSE': rmse_values.values(),
    'MAE': mae_values.values(),
    'Accuracy': accuracy.values()
})
title = "Prophet Perfomance Metrics for Forecast Variables"
format_dict = {'MSE': '{:.2f}', 'RMSE': '{:.2f}', 'MAE': '{:.2f}'}
table_styles = [
    {'selector': 'caption',
     'props': [
         ('fontSize', '40pt'),
         ('textAlign', 'center'),
         ('color', 'black'),
         ('fontWeight', 'bold')
     ]},
    {'selector': 'td:hover',
     'props': [('font-size', '20pt')]},
    {'selector': 'th',
     'props': [('width', '100px')]}
]

styled_df_fixed = results_df.style.format(format_dict).set_table_styles(table_styles) \
    .set_caption(title) \
    .background_gradient(subset=['MSE', 'RMSE'], cmap='Greens') \
    .set_properties(**{'width': '100px', 'height': '40px', 'text-align': 'center'})

styled_df_fixed

# @title
mse_values = {
    'DRC-cases': 253161.0250997894,
    'DRC-deaths': 61.12,
    'PRECTOTCORR': 459.60,
    'T2M': 2.02,
    'T2M_MAX': 6.0,
    'T2M_MIN': 0.75,
    'rfe': 485.57
}
mae_values = {
    'DRC-cases': 510.6,
    'DRC-deaths': 5.71,
    'PRECTOTCORR': 17.48,
    'T2M': 1.27,
    'T2M_MAX': 2.40,
    'T2M_MIN': 0.98,
    'rfe': 14.3
}
accuracy = {
    'DRC-cases': '-',
    'DRC-deaths': '-',
    'PRECTOTCORR': '18.9%',
    'T2M': '95.13%',
    'T2M_MAX': '92.73%',
    'T2M_MIN': '95.14%',
    'rfe': '91.3%'
}
# Calculate RMSE values
rmse_values = {key: np.sqrt(value) for key, value in mse_values.items()}

# Create a dataframe to display the results
results_df = pd.DataFrame({
    'Variable': mse_values.keys(),
    'MSE': mse_values.values(),
    'RMSE': rmse_values.values(),
    'MAE': mae_values.values(),
    'Accuracy': accuracy.values()
})
title = "SARIMAX Perfomance Metrics for Forecast Variables"
format_dict = {'MSE': '{:.2f}', 'RMSE': '{:.2f}', 'MAE': '{:.2f}'}
table_styles = [
    {'selector': 'caption',
     'props': [
         ('fontSize', '40pt'),
         ('textAlign', 'center'),
         ('color', 'black'),
         ('fontWeight', 'bold')
     ]},
    {'selector': 'td:hover',
     'props': [('font-size', '20pt')]},
    {'selector': 'th',
     'props': [('width', '100px')]}
]

styled_df_fixed = results_df.style.format(format_dict).set_table_styles(table_styles) \
    .set_caption(title) \
    .background_gradient(subset=['MSE', 'RMSE'], cmap='Greens') \
    .set_properties(**{'width': '100px', 'height': '40px', 'text-align': 'center'})

styled_df_fixed

# @title

from sklearn.metrics import mean_absolute_error

# Load the dataset
data = df

#df = data.reset_index()

# Define columns to forecast and color scheme
columns_to_forecast = ['zimbabwe_cases', 'Zimbabwe_deaths', 'PRECTOTCORR', 'T2M', 'T2M_MAX', 'T2M_MIN']
colors = ['blue', 'green', 'red', 'cyan', 'magenta', 'yellow']

# Split the data into training (up to 2022) and testing (2023 up to September)
train_df = df[df['date'] <= '2023-08-18']
test_df = df[(df['date'].dt.year == 2023) & (df['date'].dt.month <= 8)]

# Prepare for plotting
plt.figure(figsize=(15, 8))

# Initialize dictionaries to store metrics
mae_values = {}
accuracy_values = {}
epsilon = 1e-4
forecast_dfs = {}
# Loop through each column to forecast and calculate metrics
for idx, col in enumerate(columns_to_forecast):
    # Preparing data for Prophet
    prophet_data = train_df[['date', col]].copy()
    prophet_data.columns = ['ds', 'y']

    # Fitting the Prophet model
    model = Prophet(interval_width=0.95,weekly_seasonality=True)
    model.fit(prophet_data)

    # Calculate the number of weeks from the end of November 2023 to the end of December 2024

    start_forecast_date = pd.to_datetime("2023-08-18")
    end_forecast_date = pd.to_datetime("2024-10-27")
    number_of_weeks = ((end_forecast_date - start_forecast_date) // np.timedelta64(1, 'W')) + 1

    # Create future dataframe with weekly frequency
    future = model.make_future_dataframe(periods=number_of_weeks, freq='W')

    # Continue with the forecast and plotting as before


    forecast = model.predict(future)

    # Extract forecasted values for January to September 2023
    forecast_2023 = forecast[forecast['ds'].isin(test_df['date'])]['yhat']

    actual_2023 = test_df[col]
    # Create a new DataFrame for the forecast
    forecast_df = forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].copy()
    forecast_df.columns = ['Date', f'Forecast_{col}', f'Lower_CI_{col}', f'Upper_CI_{col}']

    # Store the forecast DataFrame in the dictionary
    forecast_dfs[col] = forecast_df

    # Calculate MAE and accuracy (using MAPE)

    mae = mean_absolute_error(actual_2023, forecast_2023)
    mape = np.mean(np.abs((actual_2023 - forecast_2023) / (actual_2023 + epsilon))) * 100
    accuracy = 100 - mape

    # Store results
    mae_values[col] = mae
    accuracy_values[col] = accuracy

    # Plotting the forecast and actual values
    plt.plot(forecast['ds'], forecast['yhat'], color=colors[idx], label=f'Forecast {col}')
    plt.plot(train_df['date'], train_df[col], color=colors[idx], linestyle='--', label=f'Observed {col}')

# Finalize plot settings
plt.legend()
plt.xlabel("Date")
plt.ylabel("Values")
plt.title("Forecast vs Actual Data")
plt.show()


# Export each forecast to a separate CSV file
for col, forecast_df in forecast_dfs.items():
    # Filter to include only forecast values for 2024
    forecast_2023_2024_df = forecast_df[(forecast_df['Date'] >= pd.to_datetime("2023-08-18")) & (forecast_df['Date'] <= pd.to_datetime("2024-10-27"))]
    forecast_2023_2024_df.to_csv(f'forecast_{col}_2023_12_to_2024_12_weekly_with_ci.csv', index=False)


# Display the MAE and accuracy values
print("MAE Values:", mae_values)
print("Accuracy Values:", accuracy_values)

